<!DOCTYPE html>
<html>
<head>
  <title>Spline Animation Demo</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f5f5f5;
    }

    h1 {
      color: #333;
    }

    .demo-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-top: 20px;
    }

    .demo {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .demo h2 {
      margin-top: 0;
      color: #555;
      font-size: 18px;
    }

    canvas {
      border: 2px solid #ddd;
      border-radius: 4px;
      background: white;
    }

    .controls {
      margin-top: 10px;
    }

    button {
      padding: 8px 16px;
      margin-right: 8px;
      border: none;
      border-radius: 4px;
      background: #4CAF50;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }

    button:hover {
      background: #45a049;
    }

    button:active {
      background: #3d8b40;
    }

    .info {
      margin-top: 10px;
      font-size: 12px;
      color: #666;
      line-height: 1.5;
    }
  </style>
</head>
<body>
  <h1>Spline Animation Demo</h1>
  <p>Demonstrating bezierPath() and catmullRomPath() interpolation functions</p>

  <div class="demo-container">
    <!-- Bezier Demo -->
    <div class="demo">
      <h2>Cubic Bezier Path (Relative)</h2>
      <canvas id="bezier-canvas" width="500" height="500"></canvas>
      <div class="controls">
        <button onclick="bezierAnimation.reset(); bezierAnimation.start();">Restart</button>
      </div>
      <div class="info">
        A cubic Bezier curve with control points in normalized space (0-1).<br>
        The path automatically scales with initialValue and targetValue.
      </div>
    </div>

    <!-- Catmull-Rom Demo -->
    <div class="demo">
      <h2>Catmull-Rom Spline (Absolute)</h2>
      <canvas id="catmull-canvas" width="500" height="500"></canvas>
      <div class="controls">
        <button onclick="catmullAnimation.reset(); catmullAnimation.start();">Restart</button>
      </div>
      <div class="info">
        A Catmull-Rom spline passing through multiple control points.<br>
        Points are specified in absolute coordinates.
      </div>
    </div>

    <!-- Bezier with Offset Demo -->
    <div class="demo">
      <h2>Bezier Path (Start-Relative)</h2>
      <canvas id="offset-canvas" width="500" height="500"></canvas>
      <div class="controls">
        <button onclick="offsetAnimation.reset(); offsetAnimation.start();">Restart</button>
      </div>
      <div class="info">
        Control points specified as offsets from the start position.<br>
        Useful for creating reusable path patterns.
      </div>
    </div>

    <!-- Complex Catmull-Rom Demo -->
    <div class="demo">
      <h2>Complex Catmull-Rom Path</h2>
      <canvas id="complex-canvas" width="500" height="500"></canvas>
      <div class="controls">
        <button onclick="complexAnimation.reset(); complexAnimation.start();">Restart</button>
      </div>
      <div class="info">
        A more complex path with many control points.<br>
        Demonstrates smooth interpolation through multiple waypoints.
      </div>
    </div>
  </div>

  <script src="../build/index.js"></script>
  <script>
    // -----------------------------------------------------------------------------
    // Bezier Demo (Relative to start-end)
    // -----------------------------------------------------------------------------

    const bezierCanvas = document.getElementById('bezier-canvas');
    const bezierCtx = bezierCanvas.getContext('2d');

    const bezierAnimation = new Animation({
      initialValue: { x: 50, y: 450 },
      targetValue: { x: 450, y: 50 },
      duration: 3,
      mode: AnimationMode.Auto,
      repeat: RepeatMode.Loop,
      interpolationFunction: bezierPath({
        points: [
          { x: 0.2, y: 0.9 },  // Control point 1 (normalized)
          { x: 0.8, y: 0.1 }   // Control point 2 (normalized)
        ],
        order: 3,
        relative: 'start-end'
      })
    });

    function drawBezier() {
      bezierCtx.clearRect(0, 0, bezierCanvas.width, bezierCanvas.height);

      // Draw path
      bezierCtx.strokeStyle = '#e0e0e0';
      bezierCtx.lineWidth = 2;
      bezierCtx.beginPath();
      for (let t = 0; t <= 1; t += 0.01) {
        const testAnim = new Animation({
          initialValue: { x: 50, y: 450 },
          targetValue: { x: 450, y: 50 },
          duration: 1,
          interpolationFunction: bezierPath({
            points: [
              { x: 0.2, y: 0.9 },
              { x: 0.8, y: 0.1 }
            ],
            order: 3,
            relative: 'start-end'
          })
        });
        testAnim.progress = t;
        testAnim.update(0);
        const pos = testAnim.current;
        if (t === 0) {
          bezierCtx.moveTo(pos.x, pos.y);
        } else {
          bezierCtx.lineTo(pos.x, pos.y);
        }
      }
      bezierCtx.stroke();

      // Draw control points
      const cp1 = { x: 50 + 0.2 * 400, y: 450 - 0.9 * 400 };
      const cp2 = { x: 50 + 0.8 * 400, y: 450 - 0.1 * 400 };
      bezierCtx.fillStyle = '#ff6b6b';
      bezierCtx.beginPath();
      bezierCtx.arc(cp1.x, cp1.y, 5, 0, Math.PI * 2);
      bezierCtx.arc(cp2.x, cp2.y, 5, 0, Math.PI * 2);
      bezierCtx.fill();

      // Draw object
      const pos = bezierAnimation.current;
      bezierCtx.fillStyle = '#4CAF50';
      bezierCtx.beginPath();
      bezierCtx.arc(pos.x, pos.y, 15, 0, Math.PI * 2);
      bezierCtx.fill();

      // Draw trail
      bezierCtx.strokeStyle = '#4CAF50';
      bezierCtx.lineWidth = 2;
      bezierCtx.globalAlpha = 0.3;
      bezierCtx.beginPath();
      for (let t = Math.max(0, bezierAnimation.progress - 0.2); t <= bezierAnimation.progress; t += 0.01) {
        const testAnim = new Animation({
          initialValue: { x: 50, y: 450 },
          targetValue: { x: 450, y: 50 },
          duration: 1,
          interpolationFunction: bezierPath({
            points: [
              { x: 0.2, y: 0.9 },
              { x: 0.8, y: 0.1 }
            ],
            order: 3,
            relative: 'start-end'
          })
        });
        testAnim.progress = t;
        testAnim.update(0);
        const trailPos = testAnim.current;
        if (t === Math.max(0, bezierAnimation.progress - 0.2)) {
          bezierCtx.moveTo(trailPos.x, trailPos.y);
        } else {
          bezierCtx.lineTo(trailPos.x, trailPos.y);
        }
      }
      bezierCtx.stroke();
      bezierCtx.globalAlpha = 1;
    }

    // -----------------------------------------------------------------------------
    // Catmull-Rom Demo (Absolute)
    // -----------------------------------------------------------------------------

    const catmullCanvas = document.getElementById('catmull-canvas');
    const catmullCtx = catmullCanvas.getContext('2d');

    const catmullAnimation = new Animation({
      initialValue: { x: 50, y: 250 },
      targetValue: { x: 450, y: 250 },
      duration: 4,
      mode: AnimationMode.Auto,
      repeat: RepeatMode.Loop,
      interpolationFunction: catmullRomPath({
        points: [
          { x: 150, y: 100 },
          { x: 250, y: 400 },
          { x: 350, y: 100 }
        ],
        tension: 0.5,
        relative: 'none'
      })
    });

    function drawCatmull() {
      catmullCtx.clearRect(0, 0, catmullCanvas.width, catmullCanvas.height);

      // Draw path
      catmullCtx.strokeStyle = '#e0e0e0';
      catmullCtx.lineWidth = 2;
      catmullCtx.beginPath();
      for (let t = 0; t <= 1; t += 0.01) {
        const testAnim = new Animation({
          initialValue: { x: 50, y: 250 },
          targetValue: { x: 450, y: 250 },
          duration: 1,
          interpolationFunction: catmullRomPath({
            points: [
              { x: 150, y: 100 },
              { x: 250, y: 400 },
              { x: 350, y: 100 }
            ],
            tension: 0.5,
            relative: 'none'
          })
        });
        testAnim.progress = t;
        testAnim.update(0);
        const pos = testAnim.current;
        if (t === 0) {
          catmullCtx.moveTo(pos.x, pos.y);
        } else {
          catmullCtx.lineTo(pos.x, pos.y);
        }
      }
      catmullCtx.stroke();

      // Draw control points
      const points = [
        { x: 50, y: 250 },
        { x: 150, y: 100 },
        { x: 250, y: 400 },
        { x: 350, y: 100 },
        { x: 450, y: 250 }
      ];
      catmullCtx.fillStyle = '#ff6b6b';
      for (const p of points) {
        catmullCtx.beginPath();
        catmullCtx.arc(p.x, p.y, 5, 0, Math.PI * 2);
        catmullCtx.fill();
      }

      // Draw object
      const pos = catmullAnimation.current;
      catmullCtx.fillStyle = '#2196F3';
      catmullCtx.beginPath();
      catmullCtx.arc(pos.x, pos.y, 15, 0, Math.PI * 2);
      catmullCtx.fill();
    }

    // -----------------------------------------------------------------------------
    // Offset Demo (Start-relative)
    // -----------------------------------------------------------------------------

    const offsetCanvas = document.getElementById('offset-canvas');
    const offsetCtx = offsetCanvas.getContext('2d');

    const offsetAnimation = new Animation({
      initialValue: { x: 100, y: 250 },
      targetValue: { x: 400, y: 250 },
      duration: 3,
      mode: AnimationMode.Auto,
      repeat: RepeatMode.Loop,
      interpolationFunction: bezierPath({
        points: [
          { x: 50, y: -150 },  // Offset from start
          { x: 250, y: 150 }   // Offset from start
        ],
        order: 3,
        relative: 'start'
      })
    });

    function drawOffset() {
      offsetCtx.clearRect(0, 0, offsetCanvas.width, offsetCanvas.height);

      // Draw path
      offsetCtx.strokeStyle = '#e0e0e0';
      offsetCtx.lineWidth = 2;
      offsetCtx.beginPath();
      for (let t = 0; t <= 1; t += 0.01) {
        const testAnim = new Animation({
          initialValue: { x: 100, y: 250 },
          targetValue: { x: 400, y: 250 },
          duration: 1,
          interpolationFunction: bezierPath({
            points: [
              { x: 50, y: -150 },
              { x: 250, y: 150 }
            ],
            order: 3,
            relative: 'start'
          })
        });
        testAnim.progress = t;
        testAnim.update(0);
        const pos = testAnim.current;
        if (t === 0) {
          offsetCtx.moveTo(pos.x, pos.y);
        } else {
          offsetCtx.lineTo(pos.x, pos.y);
        }
      }
      offsetCtx.stroke();

      // Draw control points (absolute positions)
      const cp1 = { x: 150, y: 100 };
      const cp2 = { x: 350, y: 400 };
      offsetCtx.fillStyle = '#ff6b6b';
      offsetCtx.beginPath();
      offsetCtx.arc(cp1.x, cp1.y, 5, 0, Math.PI * 2);
      offsetCtx.arc(cp2.x, cp2.y, 5, 0, Math.PI * 2);
      offsetCtx.fill();

      // Draw start/end points
      offsetCtx.fillStyle = '#888';
      offsetCtx.beginPath();
      offsetCtx.arc(100, 250, 5, 0, Math.PI * 2);
      offsetCtx.arc(400, 250, 5, 0, Math.PI * 2);
      offsetCtx.fill();

      // Draw object
      const pos = offsetAnimation.current;
      offsetCtx.fillStyle = '#FF9800';
      offsetCtx.beginPath();
      offsetCtx.arc(pos.x, pos.y, 15, 0, Math.PI * 2);
      offsetCtx.fill();
    }

    // -----------------------------------------------------------------------------
    // Complex Demo (Many points)
    // -----------------------------------------------------------------------------

    const complexCanvas = document.getElementById('complex-canvas');
    const complexCtx = complexCanvas.getContext('2d');

    const complexAnimation = new Animation({
      initialValue: { x: 50, y: 250 },
      targetValue: { x: 450, y: 250 },
      duration: 5,
      mode: AnimationMode.Auto,
      repeat: RepeatMode.Loop,
      interpolationFunction: catmullRomPath({
        points: [
          { x: 100, y: 100 },
          { x: 150, y: 400 },
          { x: 200, y: 100 },
          { x: 250, y: 350 },
          { x: 300, y: 150 },
          { x: 350, y: 400 },
          { x: 400, y: 100 }
        ],
        tension: 0.5,
        relative: 'none'
      })
    });

    function drawComplex() {
      complexCtx.clearRect(0, 0, complexCanvas.width, complexCanvas.height);

      // Draw path
      complexCtx.strokeStyle = '#e0e0e0';
      complexCtx.lineWidth = 2;
      complexCtx.beginPath();
      for (let t = 0; t <= 1; t += 0.005) {
        const testAnim = new Animation({
          initialValue: { x: 50, y: 250 },
          targetValue: { x: 450, y: 250 },
          duration: 1,
          interpolationFunction: catmullRomPath({
            points: [
              { x: 100, y: 100 },
              { x: 150, y: 400 },
              { x: 200, y: 100 },
              { x: 250, y: 350 },
              { x: 300, y: 150 },
              { x: 350, y: 400 },
              { x: 400, y: 100 }
            ],
            tension: 0.5,
            relative: 'none'
          })
        });
        testAnim.progress = t;
        testAnim.update(0);
        const pos = testAnim.current;
        if (t === 0) {
          complexCtx.moveTo(pos.x, pos.y);
        } else {
          complexCtx.lineTo(pos.x, pos.y);
        }
      }
      complexCtx.stroke();

      // Draw control points
      const points = [
        { x: 50, y: 250 },
        { x: 100, y: 100 },
        { x: 150, y: 400 },
        { x: 200, y: 100 },
        { x: 250, y: 350 },
        { x: 300, y: 150 },
        { x: 350, y: 400 },
        { x: 400, y: 100 },
        { x: 450, y: 250 }
      ];
      complexCtx.fillStyle = '#ff6b6b';
      for (const p of points) {
        complexCtx.beginPath();
        complexCtx.arc(p.x, p.y, 4, 0, Math.PI * 2);
        complexCtx.fill();
      }

      // Draw object
      const pos = complexAnimation.current;
      complexCtx.fillStyle = '#9C27B0';
      complexCtx.beginPath();
      complexCtx.arc(pos.x, pos.y, 15, 0, Math.PI * 2);
      complexCtx.fill();
    }

    // -----------------------------------------------------------------------------
    // Animation loop
    // -----------------------------------------------------------------------------

    function loop() {
      const dt = 1 / 60;

      bezierAnimation.update(dt);
      catmullAnimation.update(dt);
      offsetAnimation.update(dt);
      complexAnimation.update(dt);

      drawBezier();
      drawCatmull();
      drawOffset();
      drawComplex();

      requestAnimationFrame(loop);
    }

    loop();
  </script>
</body>
</html>
