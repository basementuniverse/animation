/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./index.ts":
/*!******************!*\
  !*** ./index.ts ***!
  \******************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EasingFunctions = exports.MultiAnimation = exports.Animation = exports.RepeatMode = exports.AnimationMode = void 0;\nconst utils_1 = __webpack_require__(/*! @basementuniverse/utils */ \"./node_modules/@basementuniverse/utils/utils.js\");\nconst vec_1 = __webpack_require__(/*! @basementuniverse/vec */ \"./node_modules/@basementuniverse/vec/vec.js\");\nfunction isNumber(value) {\n    return typeof value === 'number';\n}\nfunction isVec2(value) {\n    return (typeof value === 'object' &&\n        value !== null &&\n        'x' in value &&\n        'y' in value &&\n        typeof value.x === 'number' &&\n        typeof value.y === 'number');\n}\nfunction isVec3(value) {\n    return (typeof value === 'object' &&\n        value !== null &&\n        'x' in value &&\n        'y' in value &&\n        'z' in value &&\n        typeof value.x === 'number' &&\n        typeof value.y === 'number' &&\n        typeof value.z === 'number');\n}\nfunction isColor(value) {\n    return (typeof value === 'object' &&\n        value !== null &&\n        'r' in value &&\n        'g' in value &&\n        'b' in value &&\n        typeof value.r === 'number' &&\n        typeof value.g === 'number' &&\n        typeof value.b === 'number' &&\n        (typeof value.a === 'undefined' || typeof value.a === 'number'));\n}\n// -----------------------------------------------------------------------------\n// Animation options\n// -----------------------------------------------------------------------------\nvar AnimationMode;\n(function (AnimationMode) {\n    /**\n     * Animation starts automatically when created\n     */\n    AnimationMode[\"Auto\"] = \"auto\";\n    /**\n     * Animation starts when triggered manually by calling the `start` method\n     */\n    AnimationMode[\"Trigger\"] = \"trigger\";\n    /**\n     * Animation plays while triggered, and reverses when not triggered\n     */\n    AnimationMode[\"Hold\"] = \"hold\";\n    /**\n     * Animation is controlled manually by setting the progress\n     */\n    AnimationMode[\"Manual\"] = \"manual\";\n})(AnimationMode = exports.AnimationMode || (exports.AnimationMode = {}));\nvar RepeatMode;\n(function (RepeatMode) {\n    /**\n     * Animation will play once and then stop\n     */\n    RepeatMode[\"Once\"] = \"once\";\n    /**\n     * Animation will loop indefinitely\n     */\n    RepeatMode[\"Loop\"] = \"loop\";\n    /**\n     * Animation will play forward and then reverse, repeating indefinitely\n     */\n    RepeatMode[\"PingPong\"] = \"pingpong\";\n})(RepeatMode = exports.RepeatMode || (exports.RepeatMode = {}));\n// -----------------------------------------------------------------------------\n// Animation class\n// -----------------------------------------------------------------------------\nclass Animation {\n    constructor(options) {\n        this.time = 0;\n        this.hasCalledFinishedCallback = false;\n        this.progress = 0;\n        this.running = false;\n        this.holding = false;\n        this.direction = 1; // 1 = forward, -1 = backward\n        this.repeatCount = 0; // Number of completed repeats\n        this.finished = false;\n        this.options = {\n            ...Animation.DEFAULT_OPTIONS,\n            ...options,\n        };\n        this.interpolationFunction = this.getInterpolationFunction();\n        this.actualValue = options.initialValue;\n        this.direction = 1;\n        this.repeatCount = 0;\n        this.finished = false;\n        if (this.options.mode === AnimationMode.Auto) {\n            this.start();\n        }\n    }\n    getInterpolationFunction() {\n        // A custom interpolation function has been provided, so use this directly\n        if (typeof this.options.interpolationFunction === 'function') {\n            return this.options.interpolationFunction;\n        }\n        // Otherwise, look up the easing function by name (defaulting to 'linear')\n        const easingFunction = (this.options.interpolationFunction\n            ? exports.EasingFunctions[this.options.interpolationFunction]\n            : exports.EasingFunctions.linear) || exports.EasingFunctions.linear;\n        // Return a new interpolation function that uses the easing function\n        return (a, b, i) => {\n            const easedProgress = easingFunction(i, ...(this.options.interpolationFunctionParameters || []));\n            if (isNumber(a) && isNumber(b)) {\n                return (a + (b - a) * easedProgress);\n            }\n            if (isVec2(a) && isVec2(b)) {\n                const vecA = a;\n                const vecB = b;\n                return {\n                    x: vecA.x + (vecB.x - vecA.x) * easedProgress,\n                    y: vecA.y + (vecB.y - vecA.y) * easedProgress,\n                };\n            }\n            if (isVec3(a) && isVec3(b)) {\n                const vecA = a;\n                const vecB = b;\n                return {\n                    x: vecA.x + (vecB.x - vecA.x) * easedProgress,\n                    y: vecA.y + (vecB.y - vecA.y) * easedProgress,\n                    z: vecA.z + (vecB.z - vecA.z) * easedProgress,\n                };\n            }\n            if (isColor(a) && isColor(b)) {\n                const colorA = a;\n                const colorB = b;\n                return {\n                    r: colorA.r + (colorB.r - colorA.r) * easedProgress,\n                    g: colorA.g + (colorB.g - colorA.g) * easedProgress,\n                    b: colorA.b + (colorB.b - colorA.b) * easedProgress,\n                    a: (colorA.a || 1) +\n                        ((colorB.a || 1) - (colorA.a || 1)) * easedProgress,\n                };\n            }\n            throw new Error('Unsupported animatable value type');\n        };\n    }\n    get current() {\n        return this.actualValue;\n    }\n    start() {\n        this.running = true;\n    }\n    stop() {\n        this.running = false;\n    }\n    reset() {\n        this.time = 0;\n        this.progress = 0;\n        this.actualValue = this.options.initialValue;\n        this.running = false;\n        this.repeatCount = 0;\n        this.direction = 1;\n        this.finished = false;\n        this.hasCalledFinishedCallback = false;\n        if (this.options.mode === AnimationMode.Auto) {\n            this.start();\n        }\n    }\n    update(dt) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n        if (![AnimationMode.Hold, AnimationMode.Manual].includes(this.options.mode) &&\n            (!this.running || this.finished)) {\n            return;\n        }\n        // Handle delay\n        const delay = this.options.delay || 0;\n        if (this.time < delay) {\n            this.time += dt;\n            if (this.time < delay) {\n                return;\n            }\n            // If just passed the delay period, adjust dt to only use the leftover\n            dt = this.time - delay;\n            this.time = delay;\n        }\n        // Hold mode: if not running, reverse direction toward 0\n        if (this.options.mode === AnimationMode.Hold) {\n            this.running = true;\n            if (this.holding) {\n                this.direction = 1;\n            }\n            else {\n                this.direction = -1;\n                // If already at 0, do nothing\n                if (this.progress <= 0) {\n                    this.reset();\n                    return;\n                }\n                // Always \"run\" when returning to 0\n                // (so update continues until progress=0)\n            }\n        }\n        // Calculate effective duration\n        const duration = Math.max(1e-8, this.options.duration || 1);\n        let progressDelta = (dt / duration) * this.direction;\n        // Update progress\n        let newProgress = this.options.mode === AnimationMode.Manual\n            ? this.progress\n            : this.progress + progressDelta;\n        // Handle repeat modes\n        const repeat = this.options.mode === AnimationMode.Hold\n            ? RepeatMode.Once\n            : this.options.repeat || RepeatMode.Once;\n        const repeats = this.options.repeats || 0;\n        let completed = false;\n        if (repeat === RepeatMode.Once) {\n            if (this.direction === 1 && newProgress >= 1) {\n                newProgress = 1;\n                completed = true;\n            }\n            else if (this.direction === -1 && newProgress <= 0) {\n                newProgress = 0;\n                completed = true;\n            }\n        }\n        else if (repeat === RepeatMode.Loop) {\n            if (this.direction === 1 && newProgress >= 1) {\n                this.repeatCount++;\n                (_b = (_a = this.options).onRepeat) === null || _b === void 0 ? void 0 : _b.call(_a, this.repeatCount);\n                if (repeats > 0 && this.repeatCount >= repeats) {\n                    newProgress = 1;\n                    completed = true;\n                }\n                else {\n                    newProgress = newProgress % 1;\n                }\n            }\n            else if (this.direction === -1 && newProgress <= 0) {\n                this.repeatCount++;\n                (_d = (_c = this.options).onRepeat) === null || _d === void 0 ? void 0 : _d.call(_c, this.repeatCount);\n                if (repeats > 0 && this.repeatCount >= repeats) {\n                    newProgress = 0;\n                    completed = true;\n                }\n                else {\n                    newProgress = 1 + (newProgress % 1);\n                }\n            }\n        }\n        else if (repeat === RepeatMode.PingPong) {\n            if (this.direction === 1 && newProgress >= 1) {\n                this.direction = -1;\n                this.repeatCount++;\n                (_f = (_e = this.options).onRepeat) === null || _f === void 0 ? void 0 : _f.call(_e, this.repeatCount);\n                if (repeats > 0 && this.repeatCount >= repeats) {\n                    newProgress = 1;\n                    completed = true;\n                }\n                else {\n                    newProgress = 2 - newProgress; // reflect over 1\n                }\n            }\n            else if (this.direction === -1 && newProgress <= 0) {\n                this.direction = 1;\n                this.repeatCount++;\n                (_h = (_g = this.options).onRepeat) === null || _h === void 0 ? void 0 : _h.call(_g, this.repeatCount);\n                if (repeats > 0 && this.repeatCount >= repeats) {\n                    newProgress = 0;\n                    completed = true;\n                }\n                else {\n                    newProgress = -newProgress; // reflect over 0\n                }\n            }\n        }\n        // Clamp progress if needed\n        if (this.options.clamp !== false) {\n            newProgress = (0, utils_1.clamp)(newProgress, 0, 1);\n        }\n        // Track if we moved away from progress=1 to reset the finished callback flag\n        if (this.progress !== 1 && this.hasCalledFinishedCallback) {\n            this.hasCalledFinishedCallback = false;\n        }\n        this.progress = newProgress;\n        // Compute value (handle stops/keyframes)\n        let value;\n        const stops = this.options.stops;\n        if (stops && stops.length > 0) {\n            // Find the two stops surrounding progress\n            let prev = { progress: 0, value: this.options.initialValue };\n            let next = { progress: 1, value: this.options.targetValue };\n            let reachedStopIndex = -1;\n            for (let i = 0; i < stops.length; i++) {\n                if (stops[i].progress <= this.progress) {\n                    prev = stops[i];\n                    if (Math.abs(stops[i].progress - this.progress) < 1e-6) {\n                        reachedStopIndex = i;\n                    }\n                }\n                if (stops[i].progress >= this.progress) {\n                    next = stops[i];\n                    if (Math.abs(stops[i].progress - this.progress) < 1e-6) {\n                        reachedStopIndex = i;\n                    }\n                    break;\n                }\n            }\n            // Check for stops at exact progress values (0 and 1)\n            if (Math.abs(this.progress - 0) < 1e-6) {\n                const zeroStop = stops.find(s => Math.abs(s.progress - 0) < 1e-6);\n                if (zeroStop)\n                    reachedStopIndex = stops.indexOf(zeroStop);\n            }\n            else if (Math.abs(this.progress - 1) < 1e-6) {\n                const oneStop = stops.find(s => Math.abs(s.progress - 1) < 1e-6);\n                if (oneStop)\n                    reachedStopIndex = stops.indexOf(oneStop);\n            }\n            // Call onStopReached callback if we hit a stop\n            if (reachedStopIndex >= 0) {\n                (_k = (_j = this.options).onStopReached) === null || _k === void 0 ? void 0 : _k.call(_j, reachedStopIndex);\n            }\n            // If progress is before first stop\n            if (this.progress <= prev.progress) {\n                value = prev.value;\n            }\n            else if (this.progress >= next.progress) {\n                value = next.value;\n            }\n            else {\n                // Interpolate between prev and next\n                value = this.interpolationFunction(prev.value, next.value, (this.progress - prev.progress) / (next.progress - prev.progress));\n            }\n        }\n        else {\n            // Simple interpolation between initial and target\n            value = this.interpolationFunction(this.options.initialValue, this.options.targetValue, this.progress);\n        }\n        // Apply easeAmount (exponential smoothing)\n        if (this.options.easeAmount && this.options.easeAmount > 0) {\n            const ease = (0, utils_1.clamp)(this.options.easeAmount, 0, 1);\n            // Blend previous value and new value\n            if (isNumber(value) && isNumber(this.actualValue)) {\n                value = ((1 - ease) * value + ease * this.actualValue);\n            }\n            else if (isVec2(value) && isVec2(this.actualValue)) {\n                value = {\n                    x: (1 - ease) * value.x + ease * this.actualValue.x,\n                    y: (1 - ease) * value.y + ease * this.actualValue.y,\n                };\n            }\n            else if (isVec3(value) && isVec3(this.actualValue)) {\n                value = {\n                    x: (1 - ease) * value.x + ease * this.actualValue.x,\n                    y: (1 - ease) * value.y + ease * this.actualValue.y,\n                    z: (1 - ease) * value.z + ease * this.actualValue.z,\n                };\n            }\n            else if (isColor(value) && isColor(this.actualValue)) {\n                value = {\n                    r: (1 - ease) * value.r + ease * this.actualValue.r,\n                    g: (1 - ease) * value.g + ease * this.actualValue.g,\n                    b: (1 - ease) * value.b + ease * this.actualValue.b,\n                    a: (1 - ease) * ((_l = value.a) !== null && _l !== void 0 ? _l : 1) +\n                        ease * ((_m = this.actualValue.a) !== null && _m !== void 0 ? _m : 1),\n                };\n            }\n        }\n        // Apply rounding if needed\n        if (this.options.round) {\n            if (typeof this.options.round === 'function') {\n                value = this.options.round(value);\n            }\n            else if (this.options.round === true) {\n                if (isNumber(value)) {\n                    value = Math.round(value);\n                }\n                else if (isVec2(value)) {\n                    value = vec_1.vec2.map(value, Math.round);\n                }\n                else if (isVec3(value)) {\n                    value = vec_1.vec3.map(value, Math.round);\n                }\n                else if (isColor(value)) {\n                    value = {\n                        r: Math.round(value.r),\n                        g: Math.round(value.g),\n                        b: Math.round(value.b),\n                        a: value.a !== undefined ? Math.round(value.a) : undefined,\n                    };\n                }\n            }\n        }\n        this.actualValue = value;\n        // If animation is completed, stop it\n        if (completed) {\n            this.running = false;\n            this.finished = true;\n            if (!this.hasCalledFinishedCallback) {\n                (_p = (_o = this.options).onFinished) === null || _p === void 0 ? void 0 : _p.call(_o);\n                this.hasCalledFinishedCallback = true;\n            }\n        }\n    }\n}\nexports.Animation = Animation;\nAnimation.DEFAULT_OPTIONS = {\n    mode: AnimationMode.Auto,\n    repeat: RepeatMode.Once,\n    repeats: 0,\n    duration: 1,\n    delay: 0,\n    clamp: true,\n    round: false,\n    easeAmount: 0,\n    interpolationFunction: 'linear',\n    interpolationFunctionParameters: [],\n};\n// -----------------------------------------------------------------------------\n// MultiAnimation class\n// -----------------------------------------------------------------------------\nclass MultiAnimation {\n    get holding() {\n        return Object.values(this.animations).some(animation => animation === null || animation === void 0 ? void 0 : animation.holding);\n    }\n    set holding(value) {\n        for (const key in this.animations) {\n            if (this.animations[key]) {\n                this.animations[key].holding = value;\n            }\n        }\n    }\n    set progress(value) {\n        for (const key in this.animations) {\n            if (this.animations[key]) {\n                this.animations[key].progress = value;\n            }\n        }\n        this.updateCurrent();\n    }\n    constructor(options) {\n        this.animations = {};\n        this._current = {};\n        const { _default, ...rest } = options;\n        const restTyped = rest;\n        for (const key in restTyped) {\n            if (Object.prototype.hasOwnProperty.call(restTyped, key)) {\n                this.animations[key] = new Animation({\n                    ...(_default || {}),\n                    ...restTyped[key],\n                });\n            }\n        }\n        this.updateCurrent();\n    }\n    updateCurrent() {\n        for (const key in this.animations) {\n            if (this.animations[key]) {\n                this._current[key] = this.animations[key].current;\n            }\n        }\n    }\n    get current() {\n        this.updateCurrent();\n        return this._current;\n    }\n    start() {\n        var _a;\n        for (const key in this.animations) {\n            (_a = this.animations[key]) === null || _a === void 0 ? void 0 : _a.start();\n        }\n    }\n    stop() {\n        var _a;\n        for (const key in this.animations) {\n            (_a = this.animations[key]) === null || _a === void 0 ? void 0 : _a.stop();\n        }\n    }\n    reset() {\n        var _a;\n        for (const key in this.animations) {\n            (_a = this.animations[key]) === null || _a === void 0 ? void 0 : _a.reset();\n        }\n        this.updateCurrent();\n    }\n    update(dt) {\n        var _a;\n        for (const key in this.animations) {\n            (_a = this.animations[key]) === null || _a === void 0 ? void 0 : _a.update(dt);\n        }\n        this.updateCurrent();\n    }\n}\nexports.MultiAnimation = MultiAnimation;\n// -----------------------------------------------------------------------------\n// Built-in easing functions\n// -----------------------------------------------------------------------------\nexports.EasingFunctions = {\n    linear: t => t,\n    'ease-in-quad': t => t * t,\n    'ease-out-quad': t => t * (2 - t),\n    'ease-in-out-quad': t => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t),\n    'ease-in-cubic': t => t * t * t,\n    'ease-out-cubic': t => --t * t * t + 1,\n    'ease-in-out-cubic': t => t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1,\n    'ease-in-quart': t => t * t * t * t,\n    'ease-out-quart': t => 1 - --t * t * t * t,\n    'ease-in-out-quart': t => t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t,\n    'ease-in-quint': t => t * t * t * t * t,\n    'ease-out-quint': t => 1 + --t * t * t * t * t,\n    'ease-in-out-quint': t => t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t,\n    'ease-in-sine': t => 1 - Math.cos((t * Math.PI) / 2),\n    'ease-out-sine': t => Math.sin((t * Math.PI) / 2),\n    'ease-in-out-sine': t => -(Math.cos(Math.PI * t) - 1) / 2,\n    'ease-in-expo': t => (t === 0 ? 0 : Math.pow(2, 10 * (t - 1))),\n    'ease-out-expo': t => (t === 1 ? 1 : 1 - Math.pow(2, -10 * t)),\n    'ease-in-out-expo': t => t === 0\n        ? 0\n        : t === 1\n            ? 1\n            : t < 0.5\n                ? Math.pow(2, 20 * t - 10) / 2\n                : (2 - Math.pow(2, -20 * t + 10)) / 2,\n    'ease-in-circ': t => 1 - Math.sqrt(1 - t * t),\n    'ease-out-circ': t => Math.sqrt(1 - --t * t),\n    'ease-in-out-circ': t => t < 0.5\n        ? (1 - Math.sqrt(1 - 4 * t * t)) / 2\n        : (Math.sqrt(1 - (2 * t - 2) * (2 * t - 2)) + 1) / 2,\n    'ease-in-back': (t, magnitude = 1.70158) => t * t * ((magnitude + 1) * t - magnitude),\n    'ease-out-back': (t, magnitude = 1.70158) => --t * t * ((magnitude + 1) * t + magnitude) + 1,\n    'ease-in-out-back': (t, magnitude = 1.70158) => {\n        const scaledTime = t * 2;\n        const scaledTime2 = scaledTime - 2;\n        const s = magnitude * 1.525;\n        if (scaledTime < 1) {\n            return 0.5 * scaledTime * scaledTime * ((s + 1) * scaledTime - s);\n        }\n        return 0.5 * (scaledTime2 * scaledTime2 * ((s + 1) * scaledTime2 + s) + 2);\n    },\n    'ease-in-elastic': (t, magnitude = 1, period = 0.3) => {\n        if (t === 0)\n            return 0;\n        if (t === 1)\n            return 1;\n        let s;\n        if (magnitude < 1) {\n            magnitude = 1;\n            s = period / 4;\n        }\n        else {\n            s = (period / (2 * Math.PI)) * Math.asin(1 / magnitude);\n        }\n        return -(magnitude *\n            Math.pow(2, 10 * (t - 1)) *\n            Math.sin(((t - 1 - s) * (2 * Math.PI)) / period));\n    },\n    'ease-out-elastic': (t, magnitude = 1, period = 0.3) => {\n        if (t === 0)\n            return 0;\n        if (t === 1)\n            return 1;\n        let s;\n        if (magnitude < 1) {\n            magnitude = 1;\n            s = period / 4;\n        }\n        else {\n            s = (period / (2 * Math.PI)) * Math.asin(1 / magnitude);\n        }\n        return (magnitude *\n            Math.pow(2, -10 * t) *\n            Math.sin(((t - s) * (2 * Math.PI)) / period) +\n            1);\n    },\n    'ease-in-out-elastic': (t, magnitude = 1, period = 0.45) => {\n        if (t === 0)\n            return 0;\n        if (t === 1)\n            return 1;\n        let s;\n        if (magnitude < 1) {\n            magnitude = 1;\n            s = period / 4;\n        }\n        else {\n            s = (period / (2 * Math.PI)) * Math.asin(1 / magnitude);\n        }\n        const scaledTime = t * 2;\n        if (scaledTime < 1) {\n            return (-0.5 *\n                (magnitude *\n                    Math.pow(2, 10 * (scaledTime - 1)) *\n                    Math.sin(((scaledTime - 1 - s) * (2 * Math.PI)) / period)));\n        }\n        return (magnitude *\n            Math.pow(2, -10 * (scaledTime - 1)) *\n            Math.sin(((scaledTime - 1 - s) * (2 * Math.PI)) / period) *\n            0.5 +\n            1);\n    },\n    'ease-in-bounce': (t, bounces = 4, decay = 2) => 1 - bounceOut(1 - t, bounces, decay),\n    'ease-out-bounce': (t, bounces = 4, decay = 2) => bounceOut(t, bounces, decay),\n    'ease-in-out-bounce': (t, bounces = 4, decay = 2) => t < 0.5\n        ? (1 - bounceOut(1 - 2 * t, bounces, decay)) * 0.5\n        : bounceOut(2 * t - 1, bounces, decay) * 0.5 + 0.5,\n};\nfunction bounceOut(t, bounces = 4, decay = 2) {\n    const pow = Math.pow(1 - t, decay);\n    return 1 - Math.abs(Math.cos(t * Math.PI * bounces)) * pow;\n}\n\n\n//# sourceURL=webpack://@basementuniverse/animation/./index.ts?\n}");

/***/ }),

/***/ "./node_modules/@basementuniverse/utils/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/@basementuniverse/utils/utils.js ***!
  \*******************************************************/
/***/ ((module) => {

eval("{/**\n * @overview A library of useful functions\n * @author Gordon Larrigan\n */\n\n/**\n * Memoize a function\n * @param {Function} f The function to memoize\n * @returns {Function} A memoized version of the function\n */\nconst memoize = f => {\n  var cache = {};\n  return function(...args) {\n    return cache[args] ?? (cache[args] = f.apply(this, args));\n  };\n};\n\n/**\n * Check if two numbers are approximately equal\n * @param {number} a Number a\n * @param {number} b Number b\n * @param {number} [p=Number.EPSILON] The precision value\n * @return {boolean} True if numbers a and b are approximately equal\n */\nconst floatEquals = (a, b, p = Number.EPSILON) => Math.abs(a - b) < p;\n\n/**\n * Clamp a number between min and max\n * @param {number} a The number to clamp\n * @param {number} [min=0] The minimum value\n * @param {number} [max=1] The maximum value\n * @return {number} A clamped number\n */\nconst clamp = (a, min = 0, max = 1) => a < min ? min : (a > max ? max : a);\n\n/**\n * Get the fractional part of a number\n * @param {number} a The number from which to get the fractional part\n * @return {number} The fractional part of the number\n */\nconst frac = a => a >= 0 ? a - Math.floor(a) : a - Math.ceil(a);\n\n/**\n * Round n to d decimal places\n * @param {number} n The number to round\n * @param {number} [d=0] The number of decimal places to round to\n * @return {number} A rounded number\n */\nconst round = (n, d = 0) => {\n  const p = Math.pow(10, d);\n  return Math.round(n * p + Number.EPSILON) / p;\n}\n\n/**\n * Do a linear interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst lerp = (a, b, i) => a + (b - a) * i;\n\n/**\n * Get the position of i between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolated value in the interval [a, b]\n * @return {number} The position of i between a and b\n */\nconst unlerp = (a, b, i) => (i - a) / (b - a);\n\n/**\n * Do a bilinear interpolation\n * @param {number} c00 Top-left value\n * @param {number} c10 Top-right value\n * @param {number} c01 Bottom-left value\n * @param {number} c11 Bottom-right value\n * @param {number} ix Interpolation value along x\n * @param {number} iy Interpolation value along y\n * @return {number} A bilinear interpolated value\n */\nconst blerp = (c00, c10, c01, c11, ix, iy) => lerp(lerp(c00, c10, ix), lerp(c01, c11, ix), iy);\n\n/**\n * Re-map a number i from range a1...a2 to b1...b2\n * @param {number} i The number to re-map\n * @param {number} a1\n * @param {number} a2\n * @param {number} b1\n * @param {number} b2\n * @return {number}\n */\nconst remap = (i, a1, a2, b1, b2) => b1 + (i - a1) * (b2 - b1) / (a2 - a1);\n\n/**\n * Do a smooth interpolation between a and b\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value\n * @return {number} An interpolated value in the interval [a, b]\n */\nconst smoothstep = (a, b, i) => lerp(a, b, 3 * Math.pow(i, 2) - 2 * Math.pow(i, 3));\n\n/**\n * Get an angle in radians\n * @param {number} degrees The angle in degrees\n * @return {number} The angle in radians\n */\nconst radians = degrees => (Math.PI / 180) * degrees;\n\n/**\n * Get an angle in degrees\n * @param {number} radians The angle in radians\n * @return {number} The angle in degrees\n */\nconst degrees = radians => (180 / Math.PI) * radians;\n\n/**\n * Get a random float in the interval [min, max)\n * @param {number} min Inclusive min\n * @param {number} max Exclusive max\n * @return {number} A random float in the interval [min, max)\n */\nconst randomBetween = (min, max) => Math.random() * (max - min) + min;\n\n/**\n * Get a random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A random integer in the interval [min, max]\n */\nconst randomIntBetween = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;\n\n/**\n * Get a normally-distributed random number\n * @param {number} [mu=0.5] The mean value\n * @param {number} [sigma=0.5] The standard deviation\n * @param {number} [samples=2] The number of samples\n * @return {number} A normally-distributed random number\n */\nconst cltRandom = (mu = 0.5, sigma = 0.5, samples = 2) => {\n  let total = 0;\n  for (let i = samples; i--;) {\n    total += Math.random();\n  }\n  return mu + (total - samples / 2) / (samples / 2) * sigma;\n};\n\n/**\n * Get a normally-distributed random integer in the interval [min, max]\n * @param {number} min Inclusive min\n * @param {number} max Inclusive max\n * @return {number} A normally-distributed random integer\n */\nconst cltRandomInt = (min, max) => Math.floor(min + cltRandom(0.5, 0.5, 2) * (max + 1 - min));\n\n/**\n * Return a weighted random integer\n * @param {Array<number>} w An array of weights\n * @return {number} An index from w\n */\nconst weightedRandom = w => {\n  let total = w.reduce((a, i) => a + i, 0), n = 0;\n  const r = Math.random() * total;\n  while (total > r) {\n    total -= w[n++];\n  }\n  return n - 1;\n};\n\n/**\n * An interpolation function\n * @callback InterpolationFunction\n * @param {number} a The minimum number\n * @param {number} b The maximum number\n * @param {number} i The interpolation value, should be in the interval [0, 1]\n * @return {number} The interpolated value in the interval [a, b]\n */\n\n/**\n * Return an interpolated value from an array\n * @param {Array<number>} a An array of values interpolate\n * @param {number} i A number in the interval [0, 1]\n * @param {InterpolationFunction} [f=Math.lerp] The interpolation function to use\n * @return {number} An interpolated value in the interval [min(a), max(a)]\n */\nconst lerpArray = (a, i, f = lerp) => {\n  const s = i * (a.length - 1);\n  const p = clamp(Math.trunc(s), 0, a.length - 1);\n  return f(a[p] || 0, a[p + 1] || 0, frac(s));\n};\n\n/**\n * Get the dot product of two vectors\n * @param {Array<number>} a Vector a\n * @param {Array<number>} b Vector b\n * @return {number} a ∙ b\n */\nconst dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\n\n/**\n * Get the factorial of a number\n * @param {number} a\n * @return {number} a!\n */\nconst factorial = a => {\n  let result = 1;\n  for (let i = 2; i <= a; i++) {\n    result *= i;\n  }\n  return result;\n};\n\n/**\n * Get the number of permutations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nPr\n */\nconst npr = (n, r) => factorial(n) / factorial(n - r);\n\n/**\n * Get the number of combinations of r elements from a set of n elements\n * @param {number} n\n * @param {number} r\n * @return {number} nCr\n */\nconst ncr = (n, r) => factorial(n) / (factorial(r) * factorial(n - r));\n\n/**\n * Generate all permutations of r elements from an array\n *\n * @example\n * ```js\n * permutations([1, 2, 3], 2);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, 2],\n *   [1, 3],\n *   [2, 1],\n *   [2, 3],\n *   [3, 1],\n *   [3, 2]\n * ]\n * ```\n * @param {Array<*>} a\n * @param {number} r The number of elements to choose in each permutation\n * @return {Array<Array<*>>} An array of permutation arrays\n */\nconst permutations = (a, r) => {\n  if (r === 1) {\n    return a.map(item => [item]);\n  }\n\n  return a.reduce(\n    (acc, item, i) => [\n      ...acc,\n      ...permutations(a.slice(0, i).concat(a.slice(i + 1)), r - 1).map(c => [item, ...c]),\n    ],\n    []\n  );\n}\n\n/**\n * Generate all combinations of r elements from an array\n *\n * @example\n * ```js\n * combinations([1, 2, 3], 2);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, 2],\n *   [1, 3],\n *   [2, 3]\n * ]\n * ```\n * @param {Array<*>} a\n * @param {number} r The number of elements to choose in each combination\n * @return {Array<Array<*>>} An array of combination arrays\n */\nconst combinations = (a, r) => {\n  if (r === 1) {\n    return a.map(item => [item]);\n  }\n\n  return a.reduce(\n    (acc, item, i) => [\n      ...acc,\n      ...combinations(a.slice(i + 1), r - 1).map(c => [item, ...c]),\n    ],\n    []\n  );\n};\n\n/**\n * Get a cartesian product of arrays\n *\n * @example\n * ```js\n * cartesian([1, 2, 3], ['a', 'b']);\n * ```\n *\n * Output:\n * ```json\n * [\n *   [1, \"a\"],\n *   [1, \"b\"],\n *   [2, \"a\"],\n *   [2, \"b\"],\n *   [3, \"a\"],\n *   [3, \"b\"]\n * ]\n * ```\n */\nconst cartesian = (...arr) =>\n  arr.reduce(\n    (a, b) => a.flatMap(c => b.map(d => [...c, d])),\n    [[]]\n  );\n\n/**\n * A function for generating array values\n * @callback TimesFunction\n * @param {number} i The array index\n * @return {*} The array value\n */\n\n/**\n * Return a new array with length n by calling function f(i) on each element\n * @param {TimesFunction} f\n * @param {number} n The size of the array\n * @return {Array<*>}\n */\nconst times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\n\n/**\n * Return an array containing numbers 0->(n - 1)\n * @param {number} n The size of the array\n * @return {Array<number>} An array of integers 0->(n - 1)\n */\nconst range = n => times(i => i, n);\n\n/**\n * Zip multiple arrays together, i.e. ([1, 2, 3], [a, b, c]) => [[1, a], [2, b], [3, c]]\n * @param {...Array<*>} a The arrays to zip\n * @return {Array<Array<*>>}\n */\nconst zip = (...a) => times(i => a.map(a => a[i]), Math.max(...a.map(a => a.length)));\n\n/**\n * Return array[i] with positive and negative wrapping\n * @param {Array<*>} a The array to access\n * @param {number} i The positively/negatively wrapped array index\n * @return {*} An element from the array\n */\nconst at = (a, i) => a[i < 0 ? a.length - (Math.abs(i + 1) % a.length) - 1 : i % a.length];\n\n/**\n * Return the last element of an array without removing it\n * @param {Array<*>} a\n * @return {*} The last element from the array\n */\nconst peek = (a) => {\n  if (!a.length) {\n    return undefined;\n  }\n\n  return a[a.length - 1];\n};\n\n/**\n * Return the index for a given position in an unrolled 2d array\n * @param {number} x The x position\n * @param {number} y The y position\n * @param {number} w The width of the 2d array\n * @returns {number} The index in the unrolled array\n */\nconst ind = (x, y, w) => x + y * w;\n\n/**\n * Return the position for a given index in an unrolled 2d array\n * @param {number} i The index\n * @param {number} w The width of the 2d array\n * @returns {Array<number>} The position as a 2-tuple\n */\nconst pos = (i, w) => [i % w, Math.floor(i / w)];\n\n/**\n * Chop an array into chunks of size n\n * @param {Array<*>} a\n * @param {number} n The chunk size\n * @return {Array<Array<*>>} An array of array chunks\n */\nconst chunk = (a, n) => times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\n\n/**\n * Randomly shuffle a shallow copy of an array\n * @param {Array<*>} a\n * @return {Array<*>} The shuffled array\n */\nconst shuffle = a => a.slice().sort(() => Math.random() - 0.5);\n\n/**\n * Flatten an object\n * @param {object} o\n * @param {string} concatenator The string to use for concatenating keys\n * @return {object} A flattened object\n */\nconst flat = (o, concatenator = '.') => {\n  return Object.keys(o).reduce((acc, key) => {\n    if (o[key] instanceof Date) {\n      return {\n        ...acc,\n        [key]: o[key].toISOString(),\n      };\n    }\n\n    if (typeof o[key] !== 'object' || !o[key]) {\n      return {\n        ...acc,\n        [key]: o[key],\n      };\n    }\n    const flattened = flat(o[key], concatenator);\n\n    return {\n      ...acc,\n      ...Object.keys(flattened).reduce(\n        (childAcc, childKey) => ({\n          ...childAcc,\n          [`${key}${concatenator}${childKey}`]: flattened[childKey],\n        }),\n        {}\n      ),\n    };\n  }, {});\n};\n\n/**\n * Unflatten an object\n * @param {object} o\n * @param {string} concatenator The string to check for in concatenated keys\n * @return {object} An un-flattened object\n */\nconst unflat = (o, concatenator = '.') => {\n  let result = {}, temp, substrings, property, i;\n\n  for (property in o) {\n    substrings = property.split(concatenator);\n    temp = result;\n    for (i = 0; i < substrings.length - 1; i++) {\n      if (!(substrings[i] in temp)) {\n        if (isFinite(substrings[i + 1])) {\n          temp[substrings[i]] = [];\n        } else {\n          temp[substrings[i]] = {};\n        }\n      }\n      temp = temp[substrings[i]];\n    }\n    temp[substrings[substrings.length - 1]] = o[property];\n  }\n\n  return result;\n};\n\n/**\n * A split predicate\n * @callback SplitPredicate\n * @param {any} value The current value\n * @return {boolean} True if the array should split at this index\n */\n\n/**\n * Split an array into sub-arrays based on a predicate\n * @param {Array<*>} array\n * @param {SplitPredicate} predicate\n * @return {Array<Array<*>>} An array of arrays\n */\nconst split = (array, predicate) => {\n  const result = [];\n  let current = [];\n  for (const value of array) {\n    if (predicate(value)) {\n      if (current.length) {\n        result.push(current);\n      }\n      current = [value];\n    } else {\n      current.push(value);\n    }\n  }\n  result.push(current);\n\n  return result;\n};\n\n/**\n * Pluck keys from an object\n * @param {object} o\n * @param {...string} keys The keys to pluck from the object\n * @return {object} An object containing the plucked keys\n */\nconst pluck = (o, ...keys) => {\n  return keys.reduce(\n    (result, key) => Object.assign(result, { [key]: o[key] }),\n    {}\n  );\n};\n\n/**\n * Exclude keys from an object\n * @param {object} o\n * @param {...string} keys The keys to exclude from the object\n * @return {object} An object containing all keys except excluded keys\n */\nconst exclude = (o, ...keys) => {\n  return Object.fromEntries(\n    Object.entries(o).filter(([key]) => !keys.includes(key))\n  );\n};\n\nif (true) {\n  module.exports = {\n    memoize,\n    floatEquals,\n    clamp,\n    frac,\n    round,\n    lerp,\n    unlerp,\n    blerp,\n    remap,\n    smoothstep,\n    radians,\n    degrees,\n    randomBetween,\n    randomIntBetween,\n    cltRandom,\n    cltRandomInt,\n    weightedRandom,\n    lerpArray,\n    dot,\n    factorial,\n    npr,\n    ncr,\n    permutations,\n    combinations,\n    cartesian,\n    times,\n    range,\n    zip,\n    at,\n    peek,\n    ind,\n    pos,\n    chunk,\n    shuffle,\n    flat,\n    unflat,\n    split,\n    pluck,\n    exclude,\n  };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/animation/./node_modules/@basementuniverse/utils/utils.js?\n}");

/***/ }),

/***/ "./node_modules/@basementuniverse/vec/vec.js":
/*!***************************************************!*\
  !*** ./node_modules/@basementuniverse/vec/vec.js ***!
  \***************************************************/
/***/ ((module) => {

eval("{/**\n * @overview A small vector and matrix library\n * @author Gordon Larrigan\n */\n\nconst _vec_times = (f, n) => Array(n).fill(0).map((_, i) => f(i));\nconst _vec_chunk = (a, n) => _vec_times(i => a.slice(i * n, i * n + n), Math.ceil(a.length / n));\nconst _vec_dot = (a, b) => a.reduce((n, v, i) => n + v * b[i], 0);\nconst _vec_is_vec2 = a => typeof a === 'object' && 'x' in a && 'y' in a;\nconst _vec_is_vec3 = a => typeof a === 'object' && 'x' in a && 'y' in a && 'z' in a;\n\n/**\n * A 2d vector\n * @typedef {Object} vec2\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n */\n\n/**\n * Create a new 2d vector\n * @param {number|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector\n * @return {vec2} A new 2d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec2(3, 2); // (3, 2)\n * let b = vec2(4);    // (4, 4)\n * let c = vec2(a);    // (3, 2)\n * let d = vec2();     // (0, 0)\n */\nconst vec2 = (x, y) => {\n  if (!x && !y) {\n    return { x: 0, y: 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0 };\n  }\n  return { x: x, y: y ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec2} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec2.components = a => [a.x, a.y];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec2} A new vector\n */\nvec2.fromComponents = components => vec2(...components.slice(0, 2));\n\n/**\n * Return a unit vector (1, 0)\n * @return {vec2} A unit vector (1, 0)\n */\nvec2.ux = () => vec2(1, 0);\n\n/**\n * Return a unit vector (0, 1)\n * @return {vec2} A unit vector (0, 1)\n */\nvec2.uy = () => vec2(0, 1);\n\n/**\n * Add vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a + b\n */\nvec2.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a - b\n */\nvec2.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b) });\n\n/**\n * Scale a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a * b\n */\nvec2.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec2.mul\n * @param {vec2} a Vector a\n * @param {number} b Scalar b\n * @return {vec2} a * b\n */\nvec2.scale = (a, b) => vec2.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec2} a Vector a\n * @param {vec2|number} b Vector or scalar b\n * @return {vec2} a / b\n */\nvec2.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.len = a => Math.sqrt(a.x * a.x + a.y * a.y);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec2} a Vector a\n * @return {number} |a|\n */\nvec2.manhattan = a => Math.abs(a.x) + Math.abs(a.y);\n\n/**\n * Normalise a vector\n * @param {vec2} a The vector to normalise\n * @return {vec2} ^a\n */\nvec2.nor = a => {\n  let len = vec2.len(a);\n  return len ? { x: a.x / len, y: a.y / len } : vec2();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a ∙ b\n */\nvec2.dot = (a, b) => a.x * b.x + a.y * b.y;\n\n/**\n * Rotate a vector by r radians\n * @param {vec2} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec2} A rotated vector\n */\nvec2.rot = (a, r) => {\n  let s = Math.sin(r),\n    c = Math.cos(r);\n  return { x: c * a.x - s * a.y, y: s * a.x + c * a.y };\n};\n\n/**\n * Fast method to rotate a vector by -90, 90 or 180 degrees\n * @param {vec2} a The vector to rotate\n * @param {number} r 1 for 90 degrees (cw), -1 for -90 degrees (ccw), 2 or -2 for 180 degrees\n * @return {vec2} A rotated vector\n */\nvec2.rotf = (a, r) => {\n  switch (r) {\n    case 1: return vec2(a.y, -a.x);\n    case -1: return vec2(-a.y, a.x);\n    case 2: case -2: return vec2(-a.x, -a.y);\n    default: return a;\n  }\n};\n\n/**\n * Scalar cross product of two vectors\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {number} a × b\n */\nvec2.cross = (a, b) => {\n  return a.x * b.y - a.y * b.x;\n};\n\n/**\n * Check if two vectors are equal\n * @param {vec2} a Vector a\n * @param {vec2} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec2.eq = (a, b) => a.x === b.x && a.y === b.y;\n\n/**\n * Get the angle of a vector\n * @param {vec2} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec2.rad = a => Math.atan2(a.y, a.x);\n\n/**\n * Copy a vector\n * @param {vec2} a The vector to copy\n * @return {vec2} A copy of vector a\n */\nvec2.cpy = a => vec2(a);\n\n/**\n * A function to call on each component of a 2d vector\n * @callback vec2MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y'} label The component label (x or y)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec2} a Vector a\n * @param {vec2MapCallback} f The function to call on each component of the vector\n * @return {vec2} Vector a mapped through f\n */\nvec2.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y') });\n\n/**\n * Convert a vector into a string\n * @param {vec2} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec2.str = (a, s = ', ') => `${a.x}${s}${a.y}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x` or `y`\n * - `u` or `v` (aliases for `x` and `y`, respectively)\n * - `X`, `Y`, `U`, `V` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec2} a The vector to swizzle\n * @param {string} [s='..'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec2(3, -2);\n * vec2.swiz(a, 'x');    // [3]\n * vec2.swiz(a, 'yx');   // [-2, 3]\n * vec2.swiz(a, 'xY');   // [3, 2]\n * vec2.swiz(a, 'Yy');   // [2, -2]\n * vec2.swiz(a, 'x.x');  // [3, -2, 3]\n * vec2.swiz(a, 'y01x'); // [-2, 0, 1, 3]\n */\nvec2.swiz = (a, s = '..') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': result.push(a.x); break;\n      case 'y': case 'v': result.push(a.y); break;\n      case 'X': case 'U': result.push(-a.x); break;\n      case 'Y': case 'V': result.push(-a.y); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 2d vector\n * @typedef {Object} polarCoordinates2d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec2} a The vector to convert\n * @return {polarCoordinates2d} The magnitude and angle of the vector\n */\nvec2.polar = a => ({ r: vec2.len(a), theta: Math.atan2(a.y, a.x) });\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The angle of the vector\n * @return {vec2} A vector with the given angle and magnitude\n */\nvec2.fromPolar = (r, theta) => vec2(r * Math.cos(theta), r * Math.sin(theta));\n\n/**\n * A 3d vector\n * @typedef {Object} vec3\n * @property {number} x The x component of the vector\n * @property {number} y The y component of the vector\n * @property {number} z The z component of the vector\n */\n\n/**\n * Create a new 3d vector\n * @param {number|vec3|vec2} [x] The x component of the vector, or a vector to copy\n * @param {number} [y] The y component of the vector, or the z component if x is a vec2\n * @param {number} [z] The z component of the vector\n * @return {vec3} A new 3d vector\n * @example <caption>various ways to initialise a vector</caption>\n * let a = vec3(3, 2, 1);       // (3, 2, 1)\n * let b = vec3(4, 5);          // (4, 5, 0)\n * let c = vec3(6);             // (6, 6, 6)\n * let d = vec3(a);             // (3, 2, 1)\n * let e = vec3();              // (0, 0, 0)\n * let f = vec3(vec2(1, 2), 3); // (1, 2, 3)\n * let g = vec3(vec2(4, 5));    // (4, 5, 0)\n */\nconst vec3 = (x, y, z) => {\n  if (!x && !y && !z) {\n    return { x: 0, y: 0, z: 0 };\n  }\n  if (_vec_is_vec3(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };\n  }\n  if (_vec_is_vec2(x)) {\n    return { x: x.x || 0, y: x.y || 0, z: y || 0 };\n  }\n  return { x: x, y: y ?? x, z: z ?? x };\n};\n\n/**\n * Get the components of a vector as an array\n * @param {vec3} a The vector to get components from\n * @return {Array<number>} The vector components as an array\n */\nvec3.components = a => [a.x, a.y, a.z];\n\n/**\n * Create a vector from an array of components\n * @param {Array<number>} components The components of the vector\n * @return {vec3} A new vector\n */\nvec3.fromComponents = components => vec3(...components.slice(0, 3));\n\n/**\n * Return a unit vector (1, 0, 0)\n * @return {vec3} A unit vector (1, 0, 0)\n */\nvec3.ux = () => vec3(1, 0, 0);\n\n/**\n * Return a unit vector (0, 1, 0)\n * @return {vec3} A unit vector (0, 1, 0)\n */\nvec3.uy = () => vec3(0, 1, 0);\n\n/**\n * Return a unit vector (0, 0, 1)\n * @return {vec3} A unit vector (0, 0, 1)\n */\nvec3.uz = () => vec3(0, 0, 1);\n\n/**\n * Add vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a + b\n */\nvec3.add = (a, b) => ({ x: a.x + (b.x ?? b), y: a.y + (b.y ?? b), z: a.z + (b.z ?? b) });\n\n/**\n * Subtract vectors\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a - b\n */\nvec3.sub = (a, b) => ({ x: a.x - (b.x ?? b), y: a.y - (b.y ?? b), z: a.z - (b.z ?? b) });\n\n/**\n * Scale a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a * b\n */\nvec3.mul = (a, b) => ({ x: a.x * (b.x ?? b), y: a.y * (b.y ?? b), z: a.z * (b.z ?? b) });\n\n/**\n * Scale a vector by a scalar, alias for vec3.mul\n * @param {vec3} a Vector a\n * @param {number} b Scalar b\n * @return {vec3} a * b\n */\nvec3.scale = (a, b) => vec3.mul(a, b);\n\n/**\n * Divide a vector\n * @param {vec3} a Vector a\n * @param {vec3|number} b Vector or scalar b\n * @return {vec3} a / b\n */\nvec3.div = (a, b) => ({ x: a.x / (b.x ?? b), y: a.y / (b.y ?? b), z: a.z / (b.z ?? b) });\n\n/**\n * Get the length of a vector\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.len = a => Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z);\n\n/**\n * Get the length of a vector using taxicab geometry\n * @param {vec3} a Vector a\n * @return {number} |a|\n */\nvec3.manhattan = a => Math.abs(a.x) + Math.abs(a.y) + Math.abs(a.z);\n\n/**\n * Normalise a vector\n * @param {vec3} a The vector to normalise\n * @return {vec3} ^a\n */\nvec3.nor = a => {\n  let len = vec3.len(a);\n  return len ? { x: a.x / len, y: a.y / len, z: a.z / len } : vec3();\n};\n\n/**\n * Get a dot product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {number} a ∙ b\n */\nvec3.dot = (a, b) => a.x * b.x + a.y * b.y + a.z * b.z;\n\n/**\n * Rotate a vector using a rotation matrix\n * @param {vec3} a The vector to rotate\n * @param {mat} m The rotation matrix\n * @return {vec3} A rotated vector\n */\nvec3.rot = (a, m) => vec3(\n  vec3.dot(vec3.fromComponents(mat.row(m, 1)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 2)), a),\n  vec3.dot(vec3.fromComponents(mat.row(m, 3)), a)\n);\n\n/**\n * Rotate a vector by r radians around the x axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotx = (a, r) => vec3(\n  a.x,\n  a.y * Math.cos(r) - a.z * Math.sin(r),\n  a.y * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the y axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.roty = (a, r) => vec3(\n  a.x * Math.cos(r) + a.z * Math.sin(r),\n  a.y,\n  -a.x * Math.sin(r) + a.z * Math.cos(r)\n);\n\n/**\n * Rotate a vector by r radians around the z axis\n * @param {vec3} a The vector to rotate\n * @param {number} r The angle to rotate by, measured in radians\n * @return {vec3} A rotated vector\n */\nvec3.rotz = (a, r) => vec3(\n  a.x * Math.cos(r) - a.y * Math.sin(r),\n  a.x * Math.sin(r) + a.y * Math.cos(r),\n  a.z\n);\n\n/**\n * Rotate a vector using a quaternion\n * @param {vec3} a The vector to rotate\n * @param {Array<number>} q The quaternion to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rotq = (v, q) => {\n  if (q.length !== 4) {\n    return vec3();\n  }\n\n  const d = Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);\n  if (d === 0) {\n    return vec3();\n  }\n\n  const uq = [q[0] / d, q[1] / d, q[2] / d, q[3] / d];\n  const u = vec3(...uq.slice(0, 3));\n  const s = uq[3];\n  return vec3.add(\n    vec3.add(\n      vec3.mul(u, 2 * vec3.dot(u, v)),\n      vec3.mul(v, s * s - vec3.dot(u, u))\n    ),\n    vec3.mul(vec3.cross(u, v), 2 * s)\n  );\n};\n\n/**\n * Rotate a vector using Euler angles\n * @param {vec3} a The vector to rotate\n * @param {vec3} e The Euler angles to rotate by\n * @return {vec3} A rotated vector\n */\nvec3.rota = (a, e) => vec3.rotz(vec3.roty(vec3.rotx(a, e.x), e.y), e.z);\n\n/**\n * Get the cross product of vectors\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {vec3} a × b\n */\nvec3.cross = (a, b) => vec3(\n  a.y * b.z - a.z * b.y,\n  a.z * b.x - a.x * b.z,\n  a.x * b.y - a.y * b.x\n);\n\n/**\n * Check if two vectors are equal\n * @param {vec3} a Vector a\n * @param {vec3} b Vector b\n * @return {boolean} True if vectors a and b are equal, false otherwise\n */\nvec3.eq = (a, b) => a.x === b.x && a.y === b.y && a.z === b.z;\n\n/**\n * Get the angle of a vector from the x axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radx = a => Math.atan2(a.z, a.y);\n\n/**\n * Get the angle of a vector from the y axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.rady = a => Math.atan2(a.x, a.y);\n\n/**\n * Get the angle of a vector from the z axis\n * @param {vec3} a Vector a\n * @return {number} The angle of vector a in radians\n */\nvec3.radz = a => Math.atan2(a.y, a.z);\n\n/**\n * Copy a vector\n * @param {vec3} a The vector to copy\n * @return {vec3} A copy of vector a\n */\nvec3.cpy = a => vec3(a);\n\n/**\n * A function to call on each component of a 3d vector\n * @callback vec3MapCallback\n * @param {number} value The component value\n * @param {'x' | 'y' | 'z'} label The component label (x, y or z)\n * @return {number} The mapped component\n */\n\n/**\n * Call a function on each component of a vector and build a new vector from the results\n * @param {vec3} a Vector a\n * @param {vec3MapCallback} f The function to call on each component of the vector\n * @return {vec3} Vector a mapped through f\n */\nvec3.map = (a, f) => ({ x: f(a.x, 'x'), y: f(a.y, 'y'), z: f(a.z, 'z') });\n\n/**\n * Convert a vector into a string\n * @param {vec3} a The vector to convert\n * @param {string} [s=', '] The separator string\n * @return {string} A string representation of the vector\n */\nvec3.str = (a, s = ', ') => `${a.x}${s}${a.y}${s}${a.z}`;\n\n/**\n * Swizzle a vector with a string of component labels\n *\n * The string can contain:\n * - `x`, `y` or `z`\n * - `u`, `v` or `w` (aliases for `x`, `y` and `z`, respectively)\n * - `r`, `g` or `b` (aliases for `x`, `y` and `z`, respectively)\n * - `X`, `Y`, `Z`, `U`, `V`, `W`, `R`, `G`, `B` (negated versions of the above)\n * - `0` or `1` (these will be passed through unchanged)\n * - `.` to return the component that would normally be at this position (or 0)\n *\n * Any other characters will default to 0\n * @param {vec3} a The vector to swizzle\n * @param {string} [s='...'] The swizzle string\n * @return {Array<number>} The swizzled components\n * @example <caption>swizzling a vector</caption>\n * let a = vec3(3, -2, 1);\n * vec3.swiz(a, 'x');     // [3]\n * vec3.swiz(a, 'zyx');   // [1, -2, 3]\n * vec3.swiz(a, 'xYZ');   // [3, 2, -1]\n * vec3.swiz(a, 'Zzx');   // [-1, 1, 3]\n * vec3.swiz(a, 'x.x');   // [3, -2, 3]\n * vec3.swiz(a, 'y01zx'); // [-2, 0, 1, 1, 3]\n */\nvec3.swiz = (a, s = '...') => {\n  const result = [];\n  s.split('').forEach((c, i) => {\n    switch (c) {\n      case 'x': case 'u': case 'r': result.push(a.x); break;\n      case 'y': case 'v': case 'g': result.push(a.y); break;\n      case 'z': case 'w': case 'b': result.push(a.z); break;\n      case 'X': case 'U': case 'R': result.push(-a.x); break;\n      case 'Y': case 'V': case 'G': result.push(-a.y); break;\n      case 'Z': case 'W': case 'B': result.push(-a.z); break;\n      case '0': result.push(0); break;\n      case '1': result.push(1); break;\n      case '.': result.push([a.x, a.y, a.z][i] ?? 0); break;\n      default: result.push(0);\n    }\n  });\n  return result;\n};\n\n/**\n * Polar coordinates for a 3d vector\n * @typedef {Object} polarCoordinates3d\n * @property {number} r The magnitude (radius) of the vector\n * @property {number} theta The tilt angle of the vector\n * @property {number} phi The pan angle of the vector\n */\n\n/**\n * Convert a vector into polar coordinates\n * @param {vec3} a The vector to convert\n * @return {polarCoordinates3d} The magnitude, tilt and pan of the vector\n */\nvec3.polar = a => {\n  let r = vec3.len(a),\n    theta = Math.acos(a.y / r),\n    phi = Math.atan2(a.z, a.x);\n  return { r, theta, phi };\n};\n\n/**\n * Convert polar coordinates into a vector\n * @param {number} r The magnitude (radius) of the vector\n * @param {number} theta The tilt of the vector\n * @param {number} phi The pan of the vector\n * @return {vec3} A vector with the given angle and magnitude\n */\nvec3.fromPolar = (r, theta, phi) => {\n  const sinTheta = Math.sin(theta);\n  return vec3(\n    r * sinTheta * Math.cos(phi),\n    r * Math.cos(theta),\n    r * sinTheta * Math.sin(phi)\n  );\n};\n\n/**\n * A matrix\n * @typedef {Object} mat\n * @property {number} m The number of rows in the matrix\n * @property {number} n The number of columns in the matrix\n * @property {Array<number>} entries The matrix values\n */\n\n/**\n * Create a new matrix\n * @param {number} [m=4] The number of rows\n * @param {number} [n=4] The number of columns\n * @param {Array<number>} [entries=[]] Matrix values in reading order\n * @return {mat} A new matrix\n */\nconst mat = (m = 4, n = 4, entries = []) => ({\n  m, n,\n  entries: entries.concat(Array(m * n).fill(0)).slice(0, m * n)\n});\n\n/**\n * Get an identity matrix of size n\n * @param {number} n The size of the matrix\n * @return {mat} An identity matrix\n */\nmat.identity = n => mat(n, n, Array(n * n).fill(0).map((v, i) => +(Math.floor(i / n) === i % n)));\n\n/**\n * Get an entry from a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {number} The value at position (i, j) in matrix a\n */\nmat.get = (a, i, j) => a.entries[(j - 1) + (i - 1) * a.n];\n\n/**\n * Set an entry of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @param {number} v The value to set in matrix a\n */\nmat.set = (a, i, j, v) => { a.entries[(j - 1) + (i - 1) * a.n] = v; };\n\n/**\n * Get a row from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} m The row offset\n * @return {Array<number>} Row m from matrix a\n */\nmat.row = (a, m) => {\n  const s = (m - 1) * a.n;\n  return a.entries.slice(s, s + a.n);\n};\n\n/**\n * Get a column from a matrix as an array\n * @param {mat} a Matrix a\n * @param {number} n The column offset\n * @return {Array<number>} Column n from matrix a\n */\nmat.col = (a, n) => _vec_times(i => mat.get(a, (i + 1), n), a.m);\n\n/**\n * Add matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a + b\n */\nmat.add = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v + b.entries[i]);\n\n/**\n * Subtract matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat} a - b\n */\nmat.sub = (a, b) => a.m === b.m && a.n === b.n && mat.map(a, (v, i) => v - b.entries[i]);\n\n/**\n * Multiply matrices\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {mat|false} ab or false if the matrices cannot be multiplied\n */\nmat.mul = (a, b) => {\n  if (a.n !== b.m) { return false; }\n  const result = mat(a.m, b.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= b.n; j++) {\n      mat.set(result, i, j, _vec_dot(mat.row(a, i), mat.col(b, j)));\n    }\n  }\n  return result;\n};\n\n/**\n * Multiply a matrix by a vector\n * @param {mat} a Matrix a\n * @param {vec2|vec3|number[]} b Vector b\n * @return {vec2|vec3|number[]|false} ab or false if the matrix and vector cannot be multiplied\n */\nmat.mulv = (a, b) => {\n  let n, bb, rt;\n  if (_vec_is_vec3(b)) {\n    bb = vec3.components(b);\n    n = 3;\n    rt = vec3.fromComponents;\n  } else if (_vec_is_vec2(b)) {\n    bb = vec2.components(b);\n    n = 2;\n    rt = vec2.fromComponents;\n  } else {\n    bb = b;\n    n = b.length ?? 0;\n    rt = v => v;\n  }\n  if (a.n !== n) { return false; }\n  const result = [];\n  for (let i = 1; i <= a.m; i++) {\n    result.push(_vec_dot(mat.row(a, i), bb));\n  }\n  return rt(result);\n}\n\n/**\n * Scale a matrix\n * @param {mat} a Matrix a\n * @param {number} b Scalar b\n * @return {mat} a * b\n */\nmat.scale = (a, b) => mat.map(a, v => v * b);\n\n/**\n * Transpose a matrix\n * @param {mat} a The matrix to transpose\n * @return {mat} A transposed matrix\n */\nmat.trans = a => mat(a.n, a.m, _vec_times(i => mat.col(a, (i + 1)), a.n).flat());\n\n/**\n * Get the minor of a matrix\n * @param {mat} a Matrix a\n * @param {number} i The row offset\n * @param {number} j The column offset\n * @return {mat|false} The (i, j) minor of matrix a or false if the matrix is not square\n */\nmat.minor = (a, i, j) => {\n  if (a.m !== a.n) { return false; }\n  const entries = [];\n  for (let ii = 1; ii <= a.m; ii++) {\n    if (ii === i) { continue; }\n    for (let jj = 1; jj <= a.n; jj++) {\n      if (jj === j) { continue; }\n      entries.push(mat.get(a, ii, jj));\n    }\n  }\n  return mat(a.m - 1, a.n - 1, entries);\n};\n\n/**\n * Get the determinant of a matrix\n * @param {mat} a Matrix a\n * @return {number|false} |a| or false if the matrix is not square\n */\nmat.det = a => {\n  if (a.m !== a.n) { return false; }\n  if (a.m === 1) {\n    return a.entries[0];\n  }\n  if (a.m === 2) {\n    return a.entries[0] * a.entries[3] - a.entries[1] * a.entries[2];\n  }\n  let total = 0, sign = 1;\n  for (let j = 1; j <= a.n; j++) {\n    total += sign * a.entries[j - 1] * mat.det(mat.minor(a, 1, j));\n    sign *= -1;\n  }\n  return total;\n};\n\n/**\n * Normalise a matrix\n * @param {mat} a The matrix to normalise\n * @return {mat|false} ^a or false if the matrix is not square\n */\nmat.nor = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  return mat.map(a, i => i * d);\n};\n\n/**\n * Get the adjugate of a matrix\n * @param {mat} a The matrix from which to get the adjugate\n * @return {mat} The adjugate of a\n */\nmat.adj = a => {\n  const minors = mat(a.m, a.n);\n  for (let i = 1; i <= a.m; i++) {\n    for (let j = 1; j <= a.n; j++) {\n      mat.set(minors, i, j, mat.det(mat.minor(a, i, j)));\n    }\n  }\n  const cofactors = mat.map(minors, (v, i) => v * (i % 2 ? -1 : 1));\n  return mat.trans(cofactors);\n};\n\n/**\n * Get the inverse of a matrix\n * @param {mat} a The matrix to invert\n * @return {mat|false} a^-1 or false if the matrix has no inverse\n */\nmat.inv = a => {\n  if (a.m !== a.n) { return false; }\n  const d = mat.det(a);\n  if (d === 0) { return false; }\n  return mat.scale(mat.adj(a), 1 / d);\n};\n\n/**\n * Check if two matrices are equal\n * @param {mat} a Matrix a\n * @param {mat} b Matrix b\n * @return {boolean} True if matrices a and b are identical, false otherwise\n */\nmat.eq = (a, b) => a.m === b.m && a.n === b.n && mat.str(a) === mat.str(b);\n\n/**\n * Copy a matrix\n * @param {mat} a The matrix to copy\n * @return {mat} A copy of matrix a\n */\nmat.cpy = a => mat(a.m, a.n, [...a.entries]);\n\n/**\n * A function to call on each entry of a matrix\n * @callback matrixMapCallback\n * @param {number} value The entry value\n * @param {number} index The entry index\n * @param {Array<number>} entries The array of matrix entries\n * @return {number} The mapped entry\n */\n\n/**\n * Call a function on each entry of a matrix and build a new matrix from the results\n * @param {mat} a Matrix a\n * @param {matrixMapCallback} f The function to call on each entry of the matrix\n * @return {mat} Matrix a mapped through f\n */\nmat.map = (a, f) => mat(a.m, a.n, a.entries.map(f));\n\n/**\n * Convert a matrix into a string\n * @param {mat} a The matrix to convert\n * @param {string} [ms=', '] The separator string for columns\n * @param {string} [ns='\\n'] The separator string for rows\n * @return {string} A string representation of the matrix\n */\nmat.str = (a, ms = ', ', ns = '\\n') => _vec_chunk(a.entries, a.n).map(r => r.join(ms)).join(ns);\n\nif (true) {\n  module.exports = { vec2, vec3, mat };\n}\n\n\n//# sourceURL=webpack://@basementuniverse/animation/./node_modules/@basementuniverse/vec/vec.js?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./index.ts");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});